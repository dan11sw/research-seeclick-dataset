# -*- coding: utf-8 -*-
"""pritok_llm_dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10lQUDZlQC_nvmDBUE6nkLS1NwjQ7BqS5
"""

!wget -O screenshot.zip https://box.nju.edu.cn/f/813897fc4edc440a9e12/?dl=1

!unzip screenshot.zip

!wget -O seeclick_web.json https://box.nju.edu.cn/f/3b0f6ccb8bed476c8e39/?dl=1

import os, os.path
import sys
import gc
import cv2
import numpy as np
from PIL import Image

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.image as mpimg

SOURCE_DIR_IMG = "/content/cpfs01/user/chengkanzhi/seeclick_web_imgs_part/"

# Получение всех файлов в директории
def getFilesByPath(dir):
  return [name for name in os.listdir(dir) if os.path.isfile(os.path.join(dir, name))]

len(getFilesByPath(SOURCE_DIR_IMG))

getFilesByPath(SOURCE_DIR_IMG)[0:5]

import psutil
process = psutil.Process()
print(process.memory_info().rss / 1024 / 1024)

import json

schemeJSON = {}
with open('/content/seeclick_web.json') as json_file:
  schemeJSON = json.load(json_file)

import psutil
process = psutil.Process()
print(process.memory_info().rss / 1024 / 1024)

len(schemeJSON)

def filteredEntries(source_scheme, dir):
  all_files = getFilesByPath(dir)
  new_scheme = []

  for i in range(0, len(source_scheme)):
    item = source_scheme[i]
    if item["img_filename"] in all_files:
      new_scheme.append(item)

  return new_scheme

subsetScheme = filteredEntries(schemeJSON, SOURCE_DIR_IMG)

schemeJSON.clear()
del schemeJSON
gc.collect()

# Сохранение частичной разметки в JSON-файл
with open('subset_norm_seeclick_web.json', 'w') as file:
    json.dump(subsetScheme, file)

len(subsetScheme)

subsetScheme[0]

tenImages = subsetScheme[0:6]

for num, item in enumerate(tenImages):
  img = mpimg.imread(SOURCE_DIR_IMG + item["img_filename"])
  plt.subplot(2, 3, num + 1)
  plt.title(num + 1)
  plt.axis('off')
  plt.imshow(img)

import jax
import jax.numpy as jnp

def bbox_2_point(bbox):
  point = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2]
  return point

def _yx_in_bounding_boxes(
    yx, bounding_boxes
):
  """Check if the (y,x) point is contained in each bounding box.

  Args:
    yx: The (y, x) coordinate in pixels of the point.
    bounding_boxes: A 2D int array of shape (num_bboxes, 4), where each row
      represents a bounding box: (y_top_left, x_top_left, box_height,
      box_width). Note: containment is inclusive of the bounding box edges.

  Returns:
    is_inside: A 1D bool array where each element specifies if the point is
      contained within the respective box.
  """
  y, x = yx

  # `bounding_boxes` has shape (n_elements, 4); we extract each array along the
  # last axis into shape (n_elements, 1), then squeeze unneeded dimension.
  top, left, height, width = [
      jnp.squeeze(v, axis=-1) for v in jnp.split(bounding_boxes, 4, axis=-1)
  ]

  # The y-axis is inverted for AndroidEnv, so bottom = top + height.
  bottom, right = top + height, left + width

  return jnp.logical_and(y >= top, y <= bottom) & jnp.logical_and(
      x >= left, x <= right)

# Денормализация данных (x, y, width, height)
def convertNormalizeBboxType1(bbox, width, height):
  new_bbox = [bbox[0], bbox[1], bbox[2] - bbox[0], bbox[3] - bbox[1]]
  new_bbox = [new_bbox[0] * width, new_bbox[1] * height, new_bbox[2] * width, new_bbox[3] * height]

  return new_bbox

# Денормализация данных (left, top, right, down)
def convertNormalizeBboxType2(bbox, width, height):
  new_bbox = [bbox[0] * width, bbox[1] * height, bbox[2] * width, bbox[3] * height]

  return new_bbox

# Визуализация изображения с четырёхугольниками
def show_image_with_bboxes(image, bboxes=None):
    img_height = image.shape[0]
    img_width = image.shape[1]

    dpi = 40

    # Размер изображения
    figsize = img_width / float(dpi), img_height / float(dpi)

    # Настройка matplotlib для визуализации
    fig, ax = plt.subplots(1, figsize=figsize)
    ax.imshow(image)

    if isinstance(bboxes, list):
      for i in range(0, len(bboxes)):
        bbox = bboxes[i]
        if (not bbox) or (len(bbox) >= 5 and not isinstance(bbox[4], str)):
          continue

        # Определение координат прямоугольника (x, y, width, height)
        x = int(bbox[0])
        y = int(bbox[1])
        width = int(bbox[2])
        height = int(bbox[3])

        # Определение цвета четырёхугольника
        color = 'black'
        if len(bbox) >= 5:
          color = 'black' if bbox[4] == "text" else 'blue'

        # Добавление в визуализацию matplotlib изображения четырёхугольника
        rect = patches.Rectangle((x, y), width, height, linewidth=5, edgecolor=color, facecolor='none')
        ax.add_patch(rect)

    # Не рисовать оси
    plt.axis('off')

    # Визуализация изображения
    plt.show()

# Визуализация изображения с точками
def show_image_with_points(image, coords=None):
    img_height = image.shape[0]
    img_width = image.shape[1]

    dpi = 40

    # Размер изображения
    figsize = img_width / float(dpi), img_height / float(dpi)

    # Настройка matplotlib для визуализации
    fig, ax = plt.subplots(1, figsize=figsize)
    ax.imshow(image)

    if isinstance(coords, list):
      for i in range(0, len(coords)):
        coord = coords[i]
        if (not coord) or (len(coord) >= 3 and not isinstance(coord[2], str)):
          continue

        # Определение координат элемента (x, y)
        x = int(coord[0])
        y = int(coord[1])

        # Определение цвета четырёхугольника
        color = 'black'
        if len(coord) >= 5:
          color = 'black' if coords[3] == "text" else 'blue'

        # Добавление в визуализацию matplotlib изображения точки
        point = patches.Circle((x, y), radius=5, edgecolor=color, facecolor=color)

        ax.add_patch(point)

    # Не рисовать оси
    plt.axis('off')

    # Визуализация изображения
    plt.show()

# Сборка данных + визуализация данных
def show_image_rect(data):
  # Чтение изображения
  img = cv2.imread(SOURCE_DIR_IMG + data["img_filename"])

  # Получение ширины и высоты изображения
  img_height = img.shape[0]
  img_width = img.shape[1]

  bboxes = []
  elements = data["elements"]

  print("Elements: ", len(elements))

  # Сборка данных о каждом элементе
  for i in range(0, len(elements)):
    temp_bbox = data["elements"][i]["bbox"]

    # Денормализация данных bbox
    temp_bbox = convertNormalizeBboxType1(temp_bbox, img_width, img_height)
    # + добавляем тип элемента, заключённого в bbox
    temp_bbox.append(data["elements"][i]["data_type"])

    bboxes.append(temp_bbox)

  # Визуализация изображения со списком bbox'ов
  show_image_with_bboxes(img, bboxes)

# Преобразование bbox в точку
def bbox_2_point(bbox):
  point = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2]
  return point

# Сборка данных + визуализация данных
def show_image_point(data):
  # Чтение изображения
  img = cv2.imread(SOURCE_DIR_IMG + data["img_filename"])

  # Получение ширины и высоты изображения
  img_height = img.shape[0]
  img_width = img.shape[1]

  points = []
  elements = data["elements"]

  print("Elements: ", len(elements))

  # Сборка данных о каждом элементе
  for i in range(0, len(elements)):
    temp_bbox = data["elements"][i]["bbox"]

    # Денормализация данных bbox
    temp_bbox = convertNormalizeBboxType2(temp_bbox, img_width, img_height)
    # Преобразование bbox в точку
    point = bbox_2_point(temp_bbox)
    # + добавляем тип элемента, заключённого в bbox
    point.append(data["elements"][i]["data_type"])

    points.append(point)

  print(points)
  # Визуализация изображения с точками элементов
  show_image_with_points(img, points)

current_item = subsetScheme[0:100][48]
show_image_point(current_item)

current_item = subsetScheme[0:100][1]
show_image_rect(current_item)

current_items = subsetScheme[0:20]

for item in current_items:
  show_image_rect(item)

